<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.sameerasw.airsync&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.sameerasw.airsync&quot;&#10;        minSdk = 32&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.sameerasw.airsync&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.sameerasw.airsync&quot;&#10;        minSdk = 32&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // DataStore for state persistence&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.1.1&quot;)&#10;    implementation(&quot;androidx.datastore:datastore-core:1.1.1&quot;)&#10;&#10;    // ViewModel and state handling&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.8.4&quot;)&#10;    implementation(&quot;androidx.compose.runtime:runtime-livedata:1.7.0&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BATTERY_STATS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.AirSync&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.AirSync&quot;&gt;&#10;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;&#10;                &lt;data android:scheme=&quot;airsync&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.MediaNotificationListener&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:permission=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.service.notification.NotificationListenerService&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BATTERY_STATS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.AirSync&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.AirSync&quot;&#10;            android:configChanges=&quot;orientation|screenSize|screenLayout|keyboardHidden&quot;&gt;&#10;            &lt;!-- Main launcher intent filter --&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;&#10;            &lt;!-- Deep link intent filter for QR codes --&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;&#10;                &lt;data android:scheme=&quot;airsync&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.MediaNotificationListener&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:permission=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.service.notification.NotificationListenerService&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sameerasw/airsync/AirSyncViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sameerasw/airsync/AirSyncViewModel.kt" />
              <option name="originalContent" value="package com.sameerasw.airsync&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;&#10;data class UiState(&#10;    val ipAddress: String = &quot;&quot;,&#10;    val port: String = &quot;&quot;,&#10;    val deviceNameInput: String = &quot;&quot;,&#10;    val customMessage: String = &quot;&quot;,&#10;    val isLoading: Boolean = false,&#10;    val response: String = &quot;&quot;,&#10;    val isDialogVisible: Boolean = false,&#10;    val showPermissionDialog: Boolean = false,&#10;    val missingPermissions: List&lt;String&gt; = emptyList(),&#10;    val isNotificationEnabled: Boolean = false,&#10;    val lastConnectedDevice: ConnectedDevice? = null&#10;)&#10;&#10;data class DeviceInfo(&#10;    val name: String = &quot;&quot;,&#10;    val localIp: String = &quot;&quot;&#10;)&#10;&#10;class AirSyncViewModel : ViewModel() {&#10;    private val _uiState = MutableStateFlow(UiState())&#10;    val uiState: StateFlow&lt;UiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _deviceInfo = MutableStateFlow(DeviceInfo())&#10;    val deviceInfo: StateFlow&lt;DeviceInfo&gt; = _deviceInfo.asStateFlow()&#10;&#10;    fun initializeState(&#10;        context: Context,&#10;        initialIp: String? = null,&#10;        initialPort: String? = null,&#10;        showConnectionDialog: Boolean = false,&#10;        pcName: String? = null&#10;    ) {&#10;        viewModelScope.launch {&#10;            // Load saved values&#10;            val savedIp = if (initialIp != null) initialIp else DataStoreUtil.getIpAddress(context).first()&#10;            val savedPort = if (initialPort != null) initialPort else DataStoreUtil.getPort(context).first()&#10;            val savedDeviceName = DataStoreUtil.getDeviceName(context).first()&#10;            val savedCustomMessage = DataStoreUtil.getCustomMessage(context).first()&#10;            val lastConnected = DataStoreUtil.getLastConnectedDevice(context).first()&#10;&#10;            // Get device info&#10;            val deviceName = if (savedDeviceName.isEmpty()) {&#10;                val autoName = DeviceInfoUtil.getDeviceName(context)&#10;                DataStoreUtil.saveDeviceName(context, autoName)&#10;                autoName&#10;            } else savedDeviceName&#10;&#10;            val localIp = DeviceInfoUtil.getWifiIpAddress(context) ?: &quot;Unknown&quot;&#10;&#10;            _deviceInfo.value = DeviceInfo(name = deviceName, localIp = localIp)&#10;&#10;            // Check permissions&#10;            val missingPermissions = PermissionUtil.getAllMissingPermissions(context)&#10;            val isNotificationEnabled = PermissionUtil.isNotificationListenerEnabled(context)&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                ipAddress = savedIp,&#10;                port = savedPort,&#10;                deviceNameInput = deviceName,&#10;                customMessage = savedCustomMessage,&#10;                isDialogVisible = showConnectionDialog,&#10;                missingPermissions = missingPermissions,&#10;                isNotificationEnabled = isNotificationEnabled,&#10;                lastConnectedDevice = lastConnected&#10;            )&#10;&#10;            // If we have PC name from QR code, store it temporarily for the dialog&#10;            if (pcName != null &amp;&amp; showConnectionDialog) {&#10;                //  pass to the dialog through the UI state&#10;                _uiState.value = _uiState.value.copy(&#10;                    lastConnectedDevice = ConnectedDevice(&#10;                        name = pcName,&#10;                        ipAddress = savedIp,&#10;                        port = savedPort,&#10;                        lastConnected = System.currentTimeMillis()&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateIpAddress(context: Context, ip: String) {&#10;        _uiState.value = _uiState.value.copy(ipAddress = ip)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.saveIpAddress(context, ip)&#10;        }&#10;    }&#10;&#10;    fun updatePort(context: Context, port: String) {&#10;        _uiState.value = _uiState.value.copy(port = port)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.savePort(context, port)&#10;        }&#10;    }&#10;&#10;    fun updateDeviceName(context: Context, name: String) {&#10;        _uiState.value = _uiState.value.copy(deviceNameInput = name)&#10;        _deviceInfo.value = _deviceInfo.value.copy(name = name)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.saveDeviceName(context, name)&#10;        }&#10;    }&#10;&#10;    fun updateCustomMessage(context: Context, message: String) {&#10;        _uiState.value = _uiState.value.copy(customMessage = message)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.saveCustomMessage(context, message)&#10;        }&#10;    }&#10;&#10;    fun setLoading(loading: Boolean) {&#10;        _uiState.value = _uiState.value.copy(isLoading = loading)&#10;    }&#10;&#10;    fun setResponse(response: String) {&#10;        _uiState.value = _uiState.value.copy(response = response)&#10;    }&#10;&#10;    fun setDialogVisible(visible: Boolean) {&#10;        _uiState.value = _uiState.value.copy(isDialogVisible = visible)&#10;    }&#10;&#10;    fun setPermissionDialogVisible(visible: Boolean) {&#10;        _uiState.value = _uiState.value.copy(showPermissionDialog = visible)&#10;    }&#10;&#10;    fun refreshPermissions(context: Context) {&#10;        val missingPermissions = PermissionUtil.getAllMissingPermissions(context)&#10;        val isNotificationEnabled = PermissionUtil.isNotificationListenerEnabled(context)&#10;        _uiState.value = _uiState.value.copy(&#10;            missingPermissions = missingPermissions,&#10;            isNotificationEnabled = isNotificationEnabled&#10;        )&#10;    }&#10;&#10;    fun refreshDeviceInfo(context: Context) {&#10;        val localIp = DeviceInfoUtil.getWifiIpAddress(context) ?: &quot;Unknown&quot;&#10;        _deviceInfo.value = _deviceInfo.value.copy(localIp = localIp)&#10;    }&#10;&#10;    fun saveLastConnectedDevice(context: Context, pcName: String? = null) {&#10;        viewModelScope.launch {&#10;            val connectedDevice = ConnectedDevice(&#10;                name = pcName ?: &quot;Desktop PC&quot;,&#10;                ipAddress = _uiState.value.ipAddress,&#10;                port = _uiState.value.port,&#10;                lastConnected = System.currentTimeMillis()&#10;            )&#10;            DataStoreUtil.saveLastConnectedDevice(context, connectedDevice)&#10;            _uiState.value = _uiState.value.copy(lastConnectedDevice = connectedDevice)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sameerasw.airsync&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;&#10;data class UiState(&#10;    val ipAddress: String = &quot;&quot;,&#10;    val port: String = &quot;&quot;,&#10;    val deviceNameInput: String = &quot;&quot;,&#10;    val customMessage: String = &quot;&quot;,&#10;    val isLoading: Boolean = false,&#10;    val response: String = &quot;&quot;,&#10;    val isDialogVisible: Boolean = false,&#10;    val showPermissionDialog: Boolean = false,&#10;    val missingPermissions: List&lt;String&gt; = emptyList(),&#10;    val isNotificationEnabled: Boolean = false,&#10;    val lastConnectedDevice: ConnectedDevice? = null,&#10;    val isNotificationSyncEnabled: Boolean = true&#10;)&#10;&#10;data class DeviceInfo(&#10;    val name: String = &quot;&quot;,&#10;    val localIp: String = &quot;&quot;&#10;)&#10;&#10;class AirSyncViewModel : ViewModel() {&#10;    private val _uiState = MutableStateFlow(UiState())&#10;    val uiState: StateFlow&lt;UiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _deviceInfo = MutableStateFlow(DeviceInfo())&#10;    val deviceInfo: StateFlow&lt;DeviceInfo&gt; = _deviceInfo.asStateFlow()&#10;&#10;    fun initializeState(&#10;        context: Context,&#10;        initialIp: String? = null,&#10;        initialPort: String? = null,&#10;        showConnectionDialog: Boolean = false,&#10;        pcName: String? = null&#10;    ) {&#10;        viewModelScope.launch {&#10;            // Load saved values&#10;            val savedIp = if (initialIp != null) initialIp else DataStoreUtil.getIpAddress(context).first()&#10;            val savedPort = if (initialPort != null) initialPort else DataStoreUtil.getPort(context).first()&#10;            val savedDeviceName = DataStoreUtil.getDeviceName(context).first()&#10;            val savedCustomMessage = DataStoreUtil.getCustomMessage(context).first()&#10;            val lastConnected = DataStoreUtil.getLastConnectedDevice(context).first()&#10;            val isNotificationSyncEnabled = DataStoreUtil.getNotificationSyncEnabled(context).first()&#10;&#10;            // Get device info&#10;            val deviceName = if (savedDeviceName.isEmpty()) {&#10;                val autoName = DeviceInfoUtil.getDeviceName(context)&#10;                DataStoreUtil.saveDeviceName(context, autoName)&#10;                autoName&#10;            } else savedDeviceName&#10;&#10;            val localIp = DeviceInfoUtil.getWifiIpAddress(context) ?: &quot;Unknown&quot;&#10;&#10;            _deviceInfo.value = DeviceInfo(name = deviceName, localIp = localIp)&#10;&#10;            // Check permissions&#10;            val missingPermissions = PermissionUtil.getAllMissingPermissions(context)&#10;            val isNotificationEnabled = PermissionUtil.isNotificationListenerEnabled(context)&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                ipAddress = savedIp,&#10;                port = savedPort,&#10;                deviceNameInput = deviceName,&#10;                customMessage = savedCustomMessage,&#10;                isDialogVisible = showConnectionDialog,&#10;                missingPermissions = missingPermissions,&#10;                isNotificationEnabled = isNotificationEnabled,&#10;                lastConnectedDevice = lastConnected,&#10;                isNotificationSyncEnabled = isNotificationSyncEnabled&#10;            )&#10;&#10;            // If we have PC name from QR code, store it temporarily for the dialog&#10;            if (pcName != null &amp;&amp; showConnectionDialog) {&#10;                //  pass to the dialog through the UI state&#10;                _uiState.value = _uiState.value.copy(&#10;                    lastConnectedDevice = ConnectedDevice(&#10;                        name = pcName,&#10;                        ipAddress = savedIp,&#10;                        port = savedPort,&#10;                        lastConnected = System.currentTimeMillis()&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateIpAddress(context: Context, ip: String) {&#10;        _uiState.value = _uiState.value.copy(ipAddress = ip)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.saveIpAddress(context, ip)&#10;        }&#10;    }&#10;&#10;    fun updatePort(context: Context, port: String) {&#10;        _uiState.value = _uiState.value.copy(port = port)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.savePort(context, port)&#10;        }&#10;    }&#10;&#10;    fun updateDeviceName(context: Context, name: String) {&#10;        _uiState.value = _uiState.value.copy(deviceNameInput = name)&#10;        _deviceInfo.value = _deviceInfo.value.copy(name = name)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.saveDeviceName(context, name)&#10;        }&#10;    }&#10;&#10;    fun updateCustomMessage(context: Context, message: String) {&#10;        _uiState.value = _uiState.value.copy(customMessage = message)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.saveCustomMessage(context, message)&#10;        }&#10;    }&#10;&#10;    fun setLoading(loading: Boolean) {&#10;        _uiState.value = _uiState.value.copy(isLoading = loading)&#10;    }&#10;&#10;    fun setResponse(response: String) {&#10;        _uiState.value = _uiState.value.copy(response = response)&#10;    }&#10;&#10;    fun setDialogVisible(visible: Boolean) {&#10;        _uiState.value = _uiState.value.copy(isDialogVisible = visible)&#10;    }&#10;&#10;    fun setPermissionDialogVisible(visible: Boolean) {&#10;        _uiState.value = _uiState.value.copy(showPermissionDialog = visible)&#10;    }&#10;&#10;    fun refreshPermissions(context: Context) {&#10;        val missingPermissions = PermissionUtil.getAllMissingPermissions(context)&#10;        val isNotificationEnabled = PermissionUtil.isNotificationListenerEnabled(context)&#10;        _uiState.value = _uiState.value.copy(&#10;            missingPermissions = missingPermissions,&#10;            isNotificationEnabled = isNotificationEnabled&#10;        )&#10;    }&#10;&#10;    fun refreshDeviceInfo(context: Context) {&#10;        val localIp = DeviceInfoUtil.getWifiIpAddress(context) ?: &quot;Unknown&quot;&#10;        _deviceInfo.value = _deviceInfo.value.copy(localIp = localIp)&#10;    }&#10;&#10;    fun saveLastConnectedDevice(context: Context, pcName: String? = null) {&#10;        viewModelScope.launch {&#10;            val connectedDevice = ConnectedDevice(&#10;                name = pcName ?: &quot;Desktop PC&quot;,&#10;                ipAddress = _uiState.value.ipAddress,&#10;                port = _uiState.value.port,&#10;                lastConnected = System.currentTimeMillis()&#10;            )&#10;            DataStoreUtil.saveLastConnectedDevice(context, connectedDevice)&#10;            _uiState.value = _uiState.value.copy(lastConnectedDevice = connectedDevice)&#10;        }&#10;    }&#10;&#10;    fun setNotificationSyncEnabled(context: Context, enabled: Boolean) {&#10;        _uiState.value = _uiState.value.copy(isNotificationSyncEnabled = enabled)&#10;        viewModelScope.launch {&#10;            DataStoreUtil.setNotificationSyncEnabled(context, enabled)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sameerasw/airsync/DataStoreUtil.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sameerasw/airsync/DataStoreUtil.kt" />
              <option name="originalContent" value="package com.sameerasw.airsync&#10;&#10;import android.content.Context&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.preferences.core.Preferences&#10;import androidx.datastore.preferences.core.booleanPreferencesKey&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = &quot;airsync_settings&quot;)&#10;&#10;data class ConnectedDevice(&#10;    val name: String,&#10;    val ipAddress: String,&#10;    val port: String,&#10;    val lastConnected: Long&#10;)&#10;&#10;object DataStoreUtil {&#10;    private val IP_ADDRESS = stringPreferencesKey(&quot;ip_address&quot;)&#10;    private val PORT = stringPreferencesKey(&quot;port&quot;)&#10;    private val DEVICE_NAME = stringPreferencesKey(&quot;device_name&quot;)&#10;    private val CUSTOM_MESSAGE = stringPreferencesKey(&quot;custom_message&quot;)&#10;    private val FIRST_RUN = booleanPreferencesKey(&quot;first_run&quot;)&#10;    private val PERMISSIONS_CHECKED = booleanPreferencesKey(&quot;permissions_checked&quot;)&#10;    private val LAST_CONNECTED_PC_NAME = stringPreferencesKey(&quot;last_connected_pc_name&quot;)&#10;    private val LAST_CONNECTED_PC_IP = stringPreferencesKey(&quot;last_connected_pc_ip&quot;)&#10;    private val LAST_CONNECTED_PC_PORT = stringPreferencesKey(&quot;last_connected_pc_port&quot;)&#10;    private val LAST_CONNECTED_TIMESTAMP = stringPreferencesKey(&quot;last_connected_timestamp&quot;)&#10;&#10;    suspend fun saveIpAddress(context: Context, ipAddress: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[IP_ADDRESS] = ipAddress&#10;        }&#10;    }&#10;&#10;    fun getIpAddress(context: Context): Flow&lt;String&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[IP_ADDRESS] ?: &quot;192.168.1.100&quot;&#10;        }&#10;    }&#10;&#10;    suspend fun savePort(context: Context, port: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[PORT] = port&#10;        }&#10;    }&#10;&#10;    fun getPort(context: Context): Flow&lt;String&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[PORT] ?: &quot;6996&quot;&#10;        }&#10;    }&#10;&#10;    suspend fun saveDeviceName(context: Context, deviceName: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[DEVICE_NAME] = deviceName&#10;        }&#10;    }&#10;&#10;    fun getDeviceName(context: Context): Flow&lt;String&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[DEVICE_NAME] ?: &quot;&quot;&#10;        }&#10;    }&#10;&#10;    suspend fun saveCustomMessage(context: Context, message: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[CUSTOM_MESSAGE] = message&#10;        }&#10;    }&#10;&#10;    fun getCustomMessage(context: Context): Flow&lt;String&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[CUSTOM_MESSAGE] ?: &quot;&quot;&quot;{&quot;type&quot;:&quot;notification&quot;,&quot;data&quot;:{&quot;title&quot;:&quot;Test&quot;,&quot;body&quot;:&quot;Hello!&quot;,&quot;app&quot;:&quot;WhatsApp&quot;}}&quot;&quot;&quot;&#10;        }&#10;    }&#10;&#10;    suspend fun setFirstRun(context: Context, isFirstRun: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[FIRST_RUN] = isFirstRun&#10;        }&#10;    }&#10;&#10;    fun getFirstRun(context: Context): Flow&lt;Boolean&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[FIRST_RUN] ?: true&#10;        }&#10;    }&#10;&#10;    suspend fun setPermissionsChecked(context: Context, checked: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[PERMISSIONS_CHECKED] = checked&#10;        }&#10;    }&#10;&#10;    fun getPermissionsChecked(context: Context): Flow&lt;Boolean&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[PERMISSIONS_CHECKED] ?: false&#10;        }&#10;    }&#10;&#10;    suspend fun saveLastConnectedDevice(context: Context, device: ConnectedDevice) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[LAST_CONNECTED_PC_NAME] = device.name&#10;            preferences[LAST_CONNECTED_PC_IP] = device.ipAddress&#10;            preferences[LAST_CONNECTED_PC_PORT] = device.port&#10;            preferences[LAST_CONNECTED_TIMESTAMP] = device.lastConnected.toString()&#10;        }&#10;    }&#10;&#10;    fun getLastConnectedDevice(context: Context): Flow&lt;ConnectedDevice?&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            val name = preferences[LAST_CONNECTED_PC_NAME]&#10;            val ip = preferences[LAST_CONNECTED_PC_IP]&#10;            val port = preferences[LAST_CONNECTED_PC_PORT]&#10;            val timestamp = preferences[LAST_CONNECTED_TIMESTAMP]&#10;&#10;            if (name != null &amp;&amp; ip != null &amp;&amp; port != null &amp;&amp; timestamp != null) {&#10;                ConnectedDevice(&#10;                    name = name,&#10;                    ipAddress = ip,&#10;                    port = port,&#10;                    lastConnected = timestamp.toLongOrNull() ?: 0L&#10;                )&#10;            } else {&#10;                null&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sameerasw.airsync&#10;&#10;import android.content.Context&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.preferences.core.Preferences&#10;import androidx.datastore.preferences.core.booleanPreferencesKey&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = &quot;airsync_settings&quot;)&#10;&#10;data class ConnectedDevice(&#10;    val name: String,&#10;    val ipAddress: String,&#10;    val port: String,&#10;    val lastConnected: Long&#10;)&#10;&#10;object DataStoreUtil {&#10;    private val IP_ADDRESS = stringPreferencesKey(&quot;ip_address&quot;)&#10;    private val PORT = stringPreferencesKey(&quot;port&quot;)&#10;    private val DEVICE_NAME = stringPreferencesKey(&quot;device_name&quot;)&#10;    private val CUSTOM_MESSAGE = stringPreferencesKey(&quot;custom_message&quot;)&#10;    private val FIRST_RUN = booleanPreferencesKey(&quot;first_run&quot;)&#10;    private val PERMISSIONS_CHECKED = booleanPreferencesKey(&quot;permissions_checked&quot;)&#10;    private val LAST_CONNECTED_PC_NAME = stringPreferencesKey(&quot;last_connected_pc_name&quot;)&#10;    private val LAST_CONNECTED_PC_IP = stringPreferencesKey(&quot;last_connected_pc_ip&quot;)&#10;    private val LAST_CONNECTED_PC_PORT = stringPreferencesKey(&quot;last_connected_pc_port&quot;)&#10;    private val LAST_CONNECTED_TIMESTAMP = stringPreferencesKey(&quot;last_connected_timestamp&quot;)&#10;    private val NOTIFICATION_SYNC_ENABLED = booleanPreferencesKey(&quot;notification_sync_enabled&quot;)&#10;&#10;    suspend fun saveIpAddress(context: Context, ipAddress: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[IP_ADDRESS] = ipAddress&#10;        }&#10;    }&#10;&#10;    fun getIpAddress(context: Context): Flow&lt;String&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[IP_ADDRESS] ?: &quot;192.168.1.100&quot;&#10;        }&#10;    }&#10;&#10;    suspend fun savePort(context: Context, port: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[PORT] = port&#10;        }&#10;    }&#10;&#10;    fun getPort(context: Context): Flow&lt;String&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[PORT] ?: &quot;6996&quot;&#10;        }&#10;    }&#10;&#10;    suspend fun saveDeviceName(context: Context, deviceName: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[DEVICE_NAME] = deviceName&#10;        }&#10;    }&#10;&#10;    fun getDeviceName(context: Context): Flow&lt;String&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[DEVICE_NAME] ?: &quot;&quot;&#10;        }&#10;    }&#10;&#10;    suspend fun saveCustomMessage(context: Context, message: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[CUSTOM_MESSAGE] = message&#10;        }&#10;    }&#10;&#10;    fun getCustomMessage(context: Context): Flow&lt;String&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[CUSTOM_MESSAGE] ?: &quot;&quot;&quot;{&quot;type&quot;:&quot;notification&quot;,&quot;data&quot;:{&quot;title&quot;:&quot;Test&quot;,&quot;body&quot;:&quot;Hello!&quot;,&quot;app&quot;:&quot;WhatsApp&quot;}}&quot;&quot;&quot;&#10;        }&#10;    }&#10;&#10;    suspend fun setFirstRun(context: Context, isFirstRun: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[FIRST_RUN] = isFirstRun&#10;        }&#10;    }&#10;&#10;    fun getFirstRun(context: Context): Flow&lt;Boolean&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[FIRST_RUN] ?: true&#10;        }&#10;    }&#10;&#10;    suspend fun setPermissionsChecked(context: Context, checked: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[PERMISSIONS_CHECKED] = checked&#10;        }&#10;    }&#10;&#10;    fun getPermissionsChecked(context: Context): Flow&lt;Boolean&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[PERMISSIONS_CHECKED] ?: false&#10;        }&#10;    }&#10;&#10;    suspend fun setNotificationSyncEnabled(context: Context, enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[NOTIFICATION_SYNC_ENABLED] = enabled&#10;        }&#10;    }&#10;&#10;    fun getNotificationSyncEnabled(context: Context): Flow&lt;Boolean&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            preferences[NOTIFICATION_SYNC_ENABLED] ?: true // Default to enabled&#10;        }&#10;    }&#10;&#10;    suspend fun saveLastConnectedDevice(context: Context, device: ConnectedDevice) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[LAST_CONNECTED_PC_NAME] = device.name&#10;            preferences[LAST_CONNECTED_PC_IP] = device.ipAddress&#10;            preferences[LAST_CONNECTED_PC_PORT] = device.port&#10;            preferences[LAST_CONNECTED_TIMESTAMP] = device.lastConnected.toString()&#10;        }&#10;    }&#10;&#10;    fun getLastConnectedDevice(context: Context): Flow&lt;ConnectedDevice?&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            val name = preferences[LAST_CONNECTED_PC_NAME]&#10;            val ip = preferences[LAST_CONNECTED_PC_IP]&#10;            val port = preferences[LAST_CONNECTED_PC_PORT]&#10;            val timestamp = preferences[LAST_CONNECTED_TIMESTAMP]&#10;&#10;            if (name != null &amp;&amp; ip != null &amp;&amp; port != null &amp;&amp; timestamp != null) {&#10;                ConnectedDevice(&#10;                    name = name,&#10;                    ipAddress = ip,&#10;                    port = port,&#10;                    lastConnected = timestamp.toLongOrNull() ?: 0L&#10;                )&#10;            } else {&#10;                null&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sameerasw/airsync/MediaNotificationListener.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sameerasw/airsync/MediaNotificationListener.kt" />
              <option name="originalContent" value="package com.sameerasw.airsync&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.media.MediaMetadata&#10;import android.media.session.MediaController&#10;import android.media.session.MediaSessionManager&#10;import android.media.session.PlaybackState&#10;import android.service.notification.NotificationListenerService&#10;import android.service.notification.StatusBarNotification&#10;import android.util.Log&#10;&#10;class MediaNotificationListener : NotificationListenerService() {&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var currentMediaInfo: MediaInfo? = null&#10;        private const val TAG = &quot;MediaNotificationListener&quot;&#10;&#10;        fun getCurrentMediaInfo(): MediaInfo? = currentMediaInfo&#10;&#10;        fun getMediaInfo(context: Context): MediaInfo {&#10;            return try {&#10;                val mediaSessionManager = context.getSystemService(Context.MEDIA_SESSION_SERVICE) as MediaSessionManager&#10;&#10;                val componentName = ComponentName(context, MediaNotificationListener::class.java)&#10;&#10;                val activeSessions = try {&#10;                    mediaSessionManager.getActiveSessions(componentName)&#10;                } catch (e: SecurityException) {&#10;                    Log.w(TAG, &quot;SecurityException getting active sessions: ${e.message}&quot;)&#10;                    emptyList()&#10;                }&#10;&#10;                Log.d(TAG, &quot;Found ${activeSessions.size} active media sessions&quot;)&#10;&#10;                if (activeSessions.isNotEmpty()) {&#10;                    for (controller in activeSessions) {&#10;                        val metadata = controller.metadata&#10;                        val playbackState = controller.playbackState&#10;&#10;                        val title = metadata?.getString(MediaMetadata.METADATA_KEY_TITLE) ?: &quot;&quot;&#10;                        val artist = metadata?.getString(MediaMetadata.METADATA_KEY_ARTIST) ?: &quot;&quot;&#10;                        val isPlaying = playbackState?.state == PlaybackState.STATE_PLAYING&#10;&#10;                        Log.d(TAG, &quot;Media session - Title: $title, Artist: $artist, Playing: $isPlaying, State: ${playbackState?.state}&quot;)&#10;&#10;                        // Return the first session that has media info or is playing&#10;                        if (title.isNotEmpty() || artist.isNotEmpty() || isPlaying) {&#10;                            return MediaInfo(&#10;                                isPlaying = isPlaying,&#10;                                title = title,&#10;                                artist = artist&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Return current cached info if no active sessions but we have cached data&#10;                currentMediaInfo?.let { cached -&gt;&#10;                    if (cached.title.isNotEmpty() || cached.artist.isNotEmpty()) {&#10;                        Log.d(TAG, &quot;Using cached media info&quot;)&#10;                        return cached.copy(isPlaying = false)&#10;                    }&#10;                }&#10;&#10;                Log.d(TAG, &quot;No media info found&quot;)&#10;                MediaInfo(false, &quot;&quot;, &quot;&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error getting media info: ${e.message}&quot;)&#10;                MediaInfo(false, &quot;&quot;, &quot;&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onListenerConnected() {&#10;        super.onListenerConnected()&#10;        Log.d(TAG, &quot;Notification listener connected&quot;)&#10;        updateMediaInfo()&#10;    }&#10;&#10;    override fun onNotificationPosted(sbn: StatusBarNotification?) {&#10;        super.onNotificationPosted(sbn)&#10;        Log.d(TAG, &quot;Notification posted: ${sbn?.packageName}&quot;)&#10;        updateMediaInfo()&#10;    }&#10;&#10;    override fun onNotificationRemoved(sbn: StatusBarNotification?) {&#10;        super.onNotificationRemoved(sbn)&#10;        Log.d(TAG, &quot;Notification removed: ${sbn?.packageName}&quot;)&#10;        updateMediaInfo()&#10;    }&#10;&#10;    private fun updateMediaInfo() {&#10;        currentMediaInfo = getMediaInfo(this)&#10;        Log.d(TAG, &quot;Updated media info: $currentMediaInfo&quot;)&#10;    }&#10;}&#10;&#10;data class MediaInfo(&#10;    val isPlaying: Boolean,&#10;    val title: String,&#10;    val artist: String&#10;)&#10;" />
              <option name="updatedContent" value="package com.sameerasw.airsync&#10;&#10;import android.app.Notification&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.media.MediaMetadata&#10;import android.media.session.MediaSessionManager&#10;import android.media.session.PlaybackState&#10;import android.service.notification.NotificationListenerService&#10;import android.service.notification.StatusBarNotification&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.BufferedReader&#10;import java.io.InputStreamReader&#10;import java.io.PrintWriter&#10;import java.net.Socket&#10;&#10;class MediaNotificationListener : NotificationListenerService() {&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var currentMediaInfo: MediaInfo? = null&#10;        private const val TAG = &quot;MediaNotificationListener&quot;&#10;&#10;        // System packages to ignore&#10;        private val SYSTEM_PACKAGES = setOf(&#10;            &quot;android&quot;,&#10;            &quot;com.android.systemui&quot;,&#10;            &quot;com.android.providers.downloads&quot;,&#10;            &quot;com.google.android.gms&quot;,&#10;            &quot;com.android.vending&quot;&#10;        )&#10;&#10;        fun getMediaInfo(context: Context): MediaInfo {&#10;            return try {&#10;                val mediaSessionManager = context.getSystemService(MEDIA_SESSION_SERVICE) as MediaSessionManager&#10;&#10;                val componentName = ComponentName(context, MediaNotificationListener::class.java)&#10;&#10;                val activeSessions = try {&#10;                    mediaSessionManager.getActiveSessions(componentName)&#10;                } catch (e: SecurityException) {&#10;                    Log.w(TAG, &quot;SecurityException getting active sessions: ${e.message}&quot;)&#10;                    emptyList()&#10;                }&#10;&#10;                Log.d(TAG, &quot;Found ${activeSessions.size} active media sessions&quot;)&#10;&#10;                if (activeSessions.isNotEmpty()) {&#10;                    for (controller in activeSessions) {&#10;                        val metadata = controller.metadata&#10;                        val playbackState = controller.playbackState&#10;&#10;                        val title = metadata?.getString(MediaMetadata.METADATA_KEY_TITLE) ?: &quot;&quot;&#10;                        val artist = metadata?.getString(MediaMetadata.METADATA_KEY_ARTIST) ?: &quot;&quot;&#10;                        val isPlaying = playbackState?.state == PlaybackState.STATE_PLAYING&#10;&#10;                        Log.d(TAG, &quot;Media session - Title: $title, Artist: $artist, Playing: $isPlaying, State: ${playbackState?.state}&quot;)&#10;&#10;                        // Return the first session that has media info or is playing&#10;                        if (title.isNotEmpty() || artist.isNotEmpty() || isPlaying) {&#10;                            return MediaInfo(&#10;                                isPlaying = isPlaying,&#10;                                title = title,&#10;                                artist = artist&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Return current cached info if no active sessions but we have cached data&#10;                currentMediaInfo?.let { cached -&gt;&#10;                    if (cached.title.isNotEmpty() || cached.artist.isNotEmpty()) {&#10;                        Log.d(TAG, &quot;Using cached media info&quot;)&#10;                        return cached.copy(isPlaying = false)&#10;                    }&#10;                }&#10;&#10;                Log.d(TAG, &quot;No media info found&quot;)&#10;                MediaInfo(false, &quot;&quot;, &quot;&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error getting media info: ${e.message}&quot;)&#10;                MediaInfo(false, &quot;&quot;, &quot;&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private val serviceJob = Job()&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob)&#10;&#10;    override fun onListenerConnected() {&#10;        super.onListenerConnected()&#10;        Log.d(TAG, &quot;Notification listener connected - Ready to sync notifications&quot;)&#10;        updateMediaInfo()&#10;    }&#10;&#10;    override fun onListenerDisconnected() {&#10;        super.onListenerDisconnected()&#10;        Log.d(TAG, &quot;Notification listener disconnected&quot;)&#10;        serviceJob.cancel()&#10;    }&#10;&#10;    override fun onNotificationPosted(sbn: StatusBarNotification?) {&#10;        super.onNotificationPosted(sbn)&#10;        sbn?.let { notification -&gt;&#10;            Log.d(TAG, &quot;Notification posted: ${notification.packageName} - ${notification.notification?.extras?.getString(Notification.EXTRA_TITLE)}&quot;)&#10;&#10;            // Update media info first&#10;            updateMediaInfo()&#10;&#10;            // Process notification for sync&#10;            processNotificationForSync(notification)&#10;        }&#10;    }&#10;&#10;    override fun onNotificationRemoved(sbn: StatusBarNotification?) {&#10;        super.onNotificationRemoved(sbn)&#10;        Log.d(TAG, &quot;Notification removed: ${sbn?.packageName}&quot;)&#10;        updateMediaInfo()&#10;    }&#10;&#10;    private fun processNotificationForSync(sbn: StatusBarNotification) {&#10;        serviceScope.launch {&#10;            try {&#10;                // Check if notification sync is enabled&#10;                val isSyncEnabled = DataStoreUtil.getNotificationSyncEnabled(this@MediaNotificationListener).first()&#10;                if (!isSyncEnabled) {&#10;                    Log.d(TAG, &quot;Notification sync is disabled, skipping notification&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Skip system notifications and media-only notifications&#10;                if (shouldSkipNotification(sbn)) {&#10;                    Log.d(TAG, &quot;Skipping notification from ${sbn.packageName}&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val notification = sbn.notification&#10;                val extras = notification.extras&#10;&#10;                val title = extras.getString(Notification.EXTRA_TITLE) ?: &quot;&quot;&#10;                val text = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString() ?: &quot;&quot;&#10;                val bigText = extras.getCharSequence(Notification.EXTRA_BIG_TEXT)?.toString()&#10;&#10;                // Use big text if available, otherwise use regular text&#10;                val body = bigText?.takeIf { it.isNotEmpty() } ?: text&#10;&#10;                // Get app name from package name&#10;                val appName = getAppNameFromPackage(sbn.packageName)&#10;&#10;                // Only sync if we have meaningful content&#10;                if (title.isNotEmpty() || body.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;Syncing notification - App: $appName, Title: $title, Body: $body&quot;)&#10;                    sendNotificationToDesktop(title, body, appName)&#10;                } else {&#10;                    Log.d(TAG, &quot;Skipping empty notification from ${sbn.packageName}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error processing notification: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun shouldSkipNotification(sbn: StatusBarNotification): Boolean {&#10;        // Skip system packages&#10;        if (SYSTEM_PACKAGES.contains(sbn.packageName)) {&#10;            return true&#10;        }&#10;&#10;        // Skip if notification is not clearable (usually system notifications)&#10;        if (!sbn.isClearable) {&#10;            return true&#10;        }&#10;&#10;        // Skip ongoing notifications (like music players, downloads, etc.)&#10;        if (sbn.notification.flags and Notification.FLAG_ONGOING_EVENT != 0) {&#10;            return true&#10;        }&#10;&#10;        // Skip notifications without meaningful content&#10;        val extras = sbn.notification.extras&#10;        val title = extras.getString(Notification.EXTRA_TITLE)&#10;        val text = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString()&#10;&#10;        if (title.isNullOrEmpty() &amp;&amp; text.isNullOrEmpty()) {&#10;            return true&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    private fun getAppNameFromPackage(packageName: String): String {&#10;        return try {&#10;            val packageManager = packageManager&#10;            val applicationInfo = packageManager.getApplicationInfo(packageName, 0)&#10;            packageManager.getApplicationLabel(applicationInfo).toString()&#10;        } catch (_: Exception) {&#10;            // Fallback to package name or friendly name&#10;            when (packageName) {&#10;                &quot;com.whatsapp&quot; -&gt; &quot;WhatsApp&quot;&#10;                &quot;com.telegram.messenger&quot; -&gt; &quot;Telegram&quot;&#10;                &quot;com.discord&quot; -&gt; &quot;Discord&quot;&#10;                &quot;com.slack&quot; -&gt; &quot;Slack&quot;&#10;                &quot;com.microsoft.teams&quot; -&gt; &quot;Microsoft Teams&quot;&#10;                &quot;com.google.android.gm&quot; -&gt; &quot;Gmail&quot;&#10;                &quot;com.android.email&quot; -&gt; &quot;Email&quot;&#10;                &quot;com.samsung.android.messaging&quot; -&gt; &quot;Messages&quot;&#10;                &quot;com.google.android.apps.messaging&quot; -&gt; &quot;Messages&quot;&#10;                else -&gt; packageName.split(&quot;.&quot;).lastOrNull()?.replaceFirstChar { it.uppercase() } ?: packageName&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun sendNotificationToDesktop(title: String, body: String, appName: String) {&#10;        try {&#10;            // Get connection settings from DataStore&#10;            val ipAddress = DataStoreUtil.getIpAddress(this).first()&#10;            val port = DataStoreUtil.getPort(this).first().toIntOrNull() ?: 6996&#10;&#10;            // Create notification JSON and ensure it's a single line&#10;            val notificationJson = JsonUtil.toSingleLine(JsonUtil.createNotificationJson(title, body, appName))&#10;&#10;            Log.d(TAG, &quot;Sending notification to $ipAddress:$port - $notificationJson&quot;)&#10;&#10;            // Send via socket&#10;            withContext(Dispatchers.IO) {&#10;                try {&#10;                    val socket = Socket(ipAddress, port)&#10;                    val output = PrintWriter(socket.getOutputStream(), true)&#10;                    val input = BufferedReader(InputStreamReader(socket.getInputStream()))&#10;&#10;                    output.println(notificationJson)&#10;                    val response = input.readLine()&#10;&#10;                    socket.close()&#10;&#10;                    Log.d(TAG, &quot;Notification sent successfully, response: $response&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Failed to send notification: ${e.message}&quot;)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error in sendNotificationToDesktop: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateMediaInfo() {&#10;        currentMediaInfo = getMediaInfo(this)&#10;        Log.d(TAG, &quot;Updated media info: $currentMediaInfo&quot;)&#10;    }&#10;}&#10;&#10;data class MediaInfo(&#10;    val isPlaying: Boolean,&#10;    val title: String,&#10;    val artist: String&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>